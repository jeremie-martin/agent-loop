name: code-duplication
description: Consolidate duplicated code with appropriate restraint

prompt_prefix: |
  FIRST: Find and read all markdown documentation in this project before doing anything else.
  Search for and read: README files (root and subdirectories), CLAUDE.md, AGENTS.md, and all
  files in docs/ or documentation/ directories. Understand the codebase's patterns, conventions,
  and architecture. Only then proceed with your task.

  IMPORTANT - When spawning sub-agents:
  Sub-agents do not automatically have the context you have. For each sub-agent you spawn:
  1. Give it the exact file paths to relevant documentation (CLAUDE.md, README, etc.)
  2. Explicitly instruct it to read those files completely before starting its task
  3. Include any other specific files it needs to examine

  Do not assume sub-agents will find documentation on their own — give them the paths.

prompt_suffix: |
  Do not use the "question" tool or any tool requiring user input.
  Stage and commit your changes at the end with a descriptive message.

modes:
  - name: consolidate
    prompt: |
      Well-factored code doesn't repeat itself unnecessarily. When the same logic
      appears in multiple places, a bug fix requires finding every copy—and missing
      one means the bug survives.

      Look for near-duplicate code: blocks of 3+ lines that appear in 3+ places
      with only minor variations (different variable names, slightly different
      parameters). These are consolidation candidates.

      But not all duplication is bad. Premature abstraction creates coupling that's
      worse than the duplication it removes. Only consolidate when:
      - The duplicates represent truly the same concept (not just similar-looking code)
      - Changes to one copy should always apply to the others
      - The resulting abstraction is simpler to understand than the duplication

      Two similar functions that might diverge in the future are better left separate.
      Code that looks the same but serves different purposes should stay separate.

      When consolidating:
      - Extract to a well-named function that captures the shared concept
      - Place the function where it logically belongs (utility module, base class)
      - Ensure all call sites work correctly with the shared implementation

      A few clear consolidations are better than aggressively DRYing everything.
      "No changes needed" is a valid outcome—some codebases have healthy duplication.

      **After completing your changes**, orchestrate verification:

      1. Spawn a sub-agent to review your work. Give it:
         - The paths to relevant documentation files and instruct it to read them first
         - The files you modified
         - Instruction to check: is the abstraction correct? Do all call sites
           work? Are there edge cases where the duplicates actually differed?

      2. Spawn a filter sub-agent. Give it the verification feedback and ask:
         which concerns are genuine issues vs stylistic preferences about
         abstraction level?

      3. Address filtered feedback, then commit.
