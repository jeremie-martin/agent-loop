name: security-hardening
description: Audit and harden security boundaries

prompt_prefix: |
  FIRST: Find and read all markdown documentation in this project before doing anything else.
  Search for and read: README files (root and subdirectories), CLAUDE.md, AGENTS.md, and all
  files in docs/ or documentation/ directories. Understand the codebase's patterns, conventions,
  and architecture. Only then proceed with your task.

  IMPORTANT - When spawning sub-agents:
  Sub-agents do not automatically have the context you have. For each sub-agent you spawn:
  1. Give it the exact file paths to relevant documentation (CLAUDE.md, README, etc.)
  2. Explicitly instruct it to read those files completely before starting its task
  3. Include any other specific files it needs to examine

  Do not assume sub-agents will find documentation on their own — give them the paths.

prompt_suffix: |
  Do not use the "question" tool or any tool requiring user input.
  Stage and commit your changes at the end with a descriptive message.

modes:
  - name: injection
    prompt: |
      A secure codebase has no injection points. User input never flows
      directly into dangerous operations—it's always sanitized, escaped, or
      parameterized first.

      Injection vulnerabilities to address:

      **SQL injection**: String concatenation or f-strings in SQL queries.
      Secure code uses parameterized queries exclusively.

      **Command injection**: User input in shell commands.
      Secure code uses subprocess with array arguments, never shell=True with
      untrusted input.

      **Path traversal**: User input in file paths.
      Secure code validates paths, resolves them, and confirms they're within
      allowed directories.

      **Template injection**: User input in template strings.
      Secure code uses template engines with auto-escaping enabled.

      Focus on the most impactful vulnerabilities—those with clear data flow
      from user input to dangerous operation. Verify each issue is actually
      exploitable before fixing; trace the data flow.

      Don't introduce new vulnerabilities while fixing others. Run tests to
      ensure functionality is preserved.

      If no injection vulnerabilities exist, "no changes needed" is valid.

      **After completing your changes**, orchestrate verification:

      1. Spawn a sub-agent to review your work. Give it:
         - The paths to relevant documentation files and instruct it to read them first
         - The files you modified
         - Instruction to check: do fixes address the vulnerabilities? Any
           new issues introduced? Do tests pass?

      2. Spawn a filter sub-agent. Give it the verification feedback and ask:
         which concerns are genuine issues vs theoretical?

      3. Address filtered feedback, then commit.

  - name: boundaries
    prompt: |
      Security happens at boundaries—where untrusted data enters the system.
      A well-defended codebase validates input at entry points, checks
      authorization consistently, and never leaks sensitive data.

      Trust boundary issues to address:

      **Missing input validation**: API endpoints, CLI arguments, file parsing
      should validate types, ranges, and formats before processing.

      **Authentication gaps**: Endpoints or operations missing auth checks.
      Sensitive operations should require authentication.

      **Authorization gaps**: Missing ownership checks allow users to access
      resources they shouldn't. Every resource access should verify permission.

      **Data exposure**: Sensitive data in logs, error messages, or responses.
      User-facing errors should be generic; details go to internal logs only.

      **Credential handling**: Hardcoded secrets should be environment variables.
      Passwords should use strong hashing (bcrypt/argon2). Tokens shouldn't
      appear in URLs.

      Focus on clear security gaps—issues where the fix is unambiguous. Prefer
      allowlists over denylists for validation.

      If boundaries are already well-guarded, "no changes needed" is valid.

      **After completing your changes**, orchestrate verification:

      1. Spawn a sub-agent to review your work. Give it:
         - The paths to relevant documentation files and instruct it to read them first
         - The files you modified
         - Instruction to check: are fixes correct? Any new issues? Do tests pass?

      2. Spawn a filter sub-agent. Give it the verification feedback and ask:
         which concerns are genuine issues vs over-engineering?

      3. Address filtered feedback, then commit.
