name: error-handling
description: Establish consistent error handling patterns with self-orchestrated verification

prompt_prefix: |
  FIRST: Find and read all markdown documentation in this project before doing anything else.
  Search for and read: README files (root and subdirectories), CLAUDE.md, AGENTS.md, and all
  files in docs/ or documentation/ directories. Understand the codebase's patterns, conventions,
  and architecture. Only then proceed with your task.

  IMPORTANT - When spawning sub-agents:
  Sub-agents do not automatically have the context you have. For each sub-agent you spawn:
  1. Give it the exact file paths to relevant documentation (CLAUDE.md, README, etc.)
  2. Explicitly instruct it to read those files completely before starting its task
  3. Include any other specific files it needs to examine

  Do not assume sub-agents will find documentation on their own â€” give them the paths.

prompt_suffix: |
  Do not use the "question" tool or any tool requiring user input.
  Stage and commit your changes at the end with a descriptive message.

modes:
  - name: patterns
    prompt: |
      Consistent error handling makes code predictable. When similar operations
      handle errors the same way, developers know what to expect and callers
      know how to respond.

      Signs of consistent error handling:
      - Similar operations use the same pattern (exceptions vs return values)
      - Exception types are semantic (ValueError for bad inputs, RuntimeError
        for impossible states, custom types for domain-specific errors)
      - Error messages explain what went wrong and include relevant context

      Identify where similar operations handle errors differently and bring them
      into alignment. Prefer the pattern already used more often in the codebase.

      Focus on inconsistencies that would confuse developers or cause bugs. A few
      meaningful fixes are better than standardizing every error message.

      Improve messages that are vague ("Error occurred") or lack context. For
      user-facing errors, avoid exposing internal details.

      **After completing your changes**, orchestrate verification:

      1. Spawn a sub-agent to review your work. Give it:
         - The paths to relevant documentation files and instruct it to read them first
         - The files you modified
         - Instruction to check: is error handling logic correct? No silent exception
           swallowing? Messages helpful and grammatically correct?

      2. Spawn a filter sub-agent. Give it the verification feedback and ask:
         which concerns are genuine vs opinions about exception hierarchy?

      3. Address filtered feedback, then commit.

  - name: propagation
    prompt: |
      Error handling sites should match what's actually raised. When catch blocks,
      tests, and documentation drift from the implementation, bugs hide and
      behavior becomes unpredictable.

      Common mismatches:
      - Catch blocks catching the wrong type or types no longer raised
      - Tests asserting wrong exception types or messages
      - Documentation describing different error behavior than the code

      The raise site is the source of truth. For each mismatch, update the catch
      block, test, or documentation to match actual behavior.

      Focus on mismatches that would cause failures or mask errors. Run tests
      after changes to verify fixes.

      If everything is already consistent, "no changes needed" is a valid outcome.

      **After completing your changes**, orchestrate verification:

      Spawn a sub-agent to review your work. Give it:
      - The paths to relevant documentation files and instruct it to read them first
      - The files you modified
      - Instruction to check: are catch blocks correct? Do tests pass?
        Any remaining mismatches?

      Address the feedback, then commit.
