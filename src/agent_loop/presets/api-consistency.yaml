name: api-consistency
description: Make API endpoints predictable with self-orchestrated verification

prompt_prefix: |
  FIRST: Find and read all markdown documentation in this project before doing anything else.
  Search for and read: README files (root and subdirectories), CLAUDE.md, AGENTS.md, and all
  files in docs/ or documentation/ directories. Understand the codebase's patterns, conventions,
  and architecture. Only then proceed with your task.

  When spawning sub-agents, explicitly instruct each one to first read all project
  documentation (README files, CLAUDE.md, AGENTS.md, docs/ and documentation/ directories)
  before starting its task.

prompt_suffix: |
  Do not use the "question" tool or any tool requiring user input.
  Stage and commit your changes at the end with a descriptive message.

modes:
  - name: contracts
    prompt: |
      Make APIs predictable. Once someone knows one endpoint, they should be able
      to guess how others work.

      Review API endpoint definitions for consistency:

      **Naming:**
      - Do resources use plural nouns? (`/users`, not `/user`)
      - Are HTTP verbs used correctly? (GET reads, POST creates, PUT/PATCH updates, DELETE removes)
      - Is nesting consistent? (`/users/{id}/posts` vs `/posts?user_id=...`)
      - Do similar operations have similar URL patterns?

      **Responses:**
      - Do success responses follow the same structure? (data wrapper, metadata location)
      - Are error responses uniform? (same fields, same HTTP status code meanings)
      - Is pagination handled consistently? (same query params, same response shape)
      - Are empty results handled the same way? (empty array vs null vs omitted)

      **Validation:**
      - Are required fields enforced consistently?
      - Do similar fields have similar validation? (email fields, dates, IDs)
      - Are validation errors structured the same way? (which field, what's wrong)
      - Is validation documented? (OpenAPI schemas, type hints)

      Where patterns are inconsistent, align with the dominant pattern. Prefer changes
      that affect fewer endpoints. Note any breaking changes that would require client
      updatesâ€”these may need versioning.

      **After completing your changes**, orchestrate verification:

      1. Spawn a sub-agent to review your work. Give it:
         - This task (API consistency)
         - The files you modified
         - Instruction to check: do changes break existing contracts unintentionally?
           Are response shapes valid? Is validation logic correct?

      2. Spawn a filter sub-agent. Give it the verification feedback and ask:
         which concerns are genuine breakages vs opinions about API design?

      3. Address filtered feedback, then commit.

  - name: propagation
    prompt: |
      Ensure API callers, tests, and docs match the actual API contracts.

      APIs have multiple consumers: internal code that calls them, tests that
      exercise them, and documentation that describes them. When these drift
      apart, bugs hide and users get confused.

      Survey the codebase for mismatches:

      **Internal callers**: Find code that calls API endpoints. Verify:
      - Request payloads match current parameter requirements
      - Response handling matches current response shapes
      - Error handling matches current error responses

      **Tests**: Find API tests. Verify:
      - Test payloads match current validation rules
      - Assertions match current response structures
      - Error case tests match current error behavior

      **Documentation**: Find API docs (OpenAPI, markdown, docstrings). Verify:
      - Documented parameters match implementation
      - Documented responses match actual responses
      - Examples are valid and current

      For each mismatch, update the caller / test / doc to match the actual API.
      The endpoint implementation is the source of truth.

      Run tests after changes to verify fixes.

      If everything is already consistent, "no changes needed" is a valid outcome.

      **After completing your changes**, orchestrate verification:

      1. Spawn a sub-agent to review your work. Give it:
         - The files you modified
         - Instruction to check: are callers correct? Do tests pass?
           Is documentation accurate?

      2. Spawn a filter sub-agent. Give it the verification feedback and ask:
         which concerns are genuine issues vs over-caution?

      3. Address filtered feedback, then commit.
