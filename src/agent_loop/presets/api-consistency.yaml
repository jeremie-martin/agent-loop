name: api-consistency
description: Make API endpoints predictable with self-orchestrated verification

prompt_prefix: |
  FIRST: Find and read all markdown documentation in this project before doing anything else.
  Search for and read: README files (root and subdirectories), CLAUDE.md, AGENTS.md, and all
  files in docs/ or documentation/ directories. Understand the codebase's patterns, conventions,
  and architecture. Only then proceed with your task.

  IMPORTANT - When spawning sub-agents:
  Sub-agents do not automatically have the context you have. For each sub-agent you spawn:
  1. Give it the exact file paths to relevant documentation (CLAUDE.md, README, etc.)
  2. Explicitly instruct it to read those files completely before starting its task
  3. Include any other specific files it needs to examine

  Do not assume sub-agents will find documentation on their own — give them the paths.

prompt_suffix: |
  Do not use the "question" tool or any tool requiring user input.
  Stage and commit your changes at the end with a descriptive message.

modes:
  - name: contracts
    prompt: |
      A well-designed API is predictable. Once someone knows one endpoint, they
      can guess how others work. Naming follows patterns, responses have consistent
      structure, and validation behaves uniformly.

      Consistent APIs have:
      - **Predictable naming**: Plural nouns for resources (`/users`), HTTP verbs
        used correctly (GET reads, POST creates, PUT/PATCH updates, DELETE removes)
      - **Uniform responses**: Same structure for success and error responses,
        consistent pagination, empty results handled the same way
      - **Consistent validation**: Similar fields validated similarly, validation
        errors structured the same way

      Identify the dominant patterns in the existing API, then bring outliers into
      alignment. Focus on inconsistencies that would confuse API consumers. A few
      meaningful fixes are better than many small changes.

      Prefer changes that affect fewer endpoints. Note any breaking changes that
      would require client updates—these may need versioning.

      If the API is already consistent, "no changes needed" is a valid outcome.

      **After completing your changes**, orchestrate verification:

      1. Spawn a sub-agent to review your work. Give it:
         - The paths to relevant documentation files and instruct it to read them first
         - The files you modified
         - Instruction to check: do changes break existing contracts unintentionally?
           Are response shapes valid? Is validation logic correct?

      2. Spawn a filter sub-agent. Give it the verification feedback and ask:
         which concerns are genuine breakages vs opinions about API design?

      3. Address filtered feedback, then commit.

  - name: propagation
    prompt: |
      API consumers should match what the API actually does. When internal callers,
      tests, and documentation drift from the implementation, bugs hide and users
      get confused.

      API consumers that need to stay synchronized:
      - **Internal callers**: Request payloads, response handling, error handling
      - **Tests**: Payloads, assertions, error case expectations
      - **Documentation**: Parameters, responses, examples

      The endpoint implementation is the source of truth. For each mismatch, update
      the consumer to match the actual API behavior.

      Focus on mismatches that would cause failures or confusion. Run tests after
      changes to verify fixes.

      If everything is already synchronized, "no changes needed" is a valid outcome.

      **After completing your changes**, orchestrate verification:

      Spawn a sub-agent to review your work. Give it:
      - The paths to relevant documentation files and instruct it to read them first
      - The files you modified
      - Instruction to check: are callers correct? Do tests pass?
        Is documentation accurate?

      Address the feedback, then commit.
