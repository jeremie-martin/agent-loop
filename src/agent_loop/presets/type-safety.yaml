name: type-safety
description: Add type annotations with self-orchestrated verification

prompt_prefix: |
  FIRST: Find and read all markdown documentation in this project before doing anything else.
  Search for and read: README files (root and subdirectories), CLAUDE.md, AGENTS.md, and all
  files in docs/ or documentation/ directories. Understand the codebase's patterns, conventions,
  and architecture. Only then proceed with your task.

  IMPORTANT - When spawning sub-agents:
  Sub-agents do not automatically have the context you have. For each sub-agent you spawn:
  1. Give it the exact file paths to relevant documentation (CLAUDE.md, README, etc.)
  2. Explicitly instruct it to read those files completely before starting its task
  3. Include any other specific files it needs to examine

  Do not assume sub-agents will find documentation on their own — give them the paths.

prompt_suffix: |
  Do not use the "question" tool or any tool requiring user input.
  Stage and commit your changes at the end with a descriptive message.

modes:
  - name: boundaries
    prompt: |
      Well-typed code makes contracts explicit. Public interfaces have clear type
      signatures, and type checkers verify callers use them correctly.

      Prioritize typing:
      - **Public interfaces**: Functions, methods, and classes other modules import.
        These need parameter and return type annotations.
      - **Internal code**: Add annotations where types aren't obvious—empty containers,
        complex expressions, ambiguous assignments.

      Don't over-annotate. `x: int = 5` adds noise. `result: dict[str, list[Event]] = {}`
      adds clarity.

      Improve existing annotations:
      - Replace bare `list`, `dict` with parameterized versions
      - Replace `Any` with specific types where known
      - Add `| None` where None is valid

      Focus on annotations that help catch bugs or clarify intent. The goal is
      types that accurately describe what the code does, not maximally strict
      types that fight the code.

      Run the type checker after changes to catch errors.

      "No changes needed" is a valid outcome.

      **After completing your changes**, orchestrate verification:

      1. Spawn a sub-agent to review your work. Give it:
         - The paths to relevant documentation files and instruct it to read them first
         - The files you modified
         - Instruction to check: are annotations correct? Does the type checker pass?
           Are there over-complicated generic types that hurt readability?

      2. Spawn a filter sub-agent. Give it the verification feedback and ask:
         which concerns are genuine vs stylistic preference?

      3. Address filtered feedback, then commit.

  - name: consistency
    prompt: |
      Consistent type annotations make a codebase predictable. Similar code uses
      similar types, type aliases are consolidated, and naming conventions are
      uniform.

      Signs of inconsistent typing:
      - Duplicate type definitions that could be consolidated
      - Inconsistent naming (`UserId` vs `UserID`)
      - Similar functions with different annotation styles

      Consolidate type definitions. Create type aliases for complex types used in
      multiple places. Focus on inconsistencies that cause confusion or make the
      type checker less useful.

      Run the type checker after changes.

      "No changes needed" is a valid outcome.

      **After completing your changes**, orchestrate verification:

      Spawn a sub-agent to review your work. Give it:
      - The paths to relevant documentation files and instruct it to read them first
      - The files you modified
      - Instruction to check: are consolidated types correct? Does the type
        checker pass? Any inconsistencies remaining?

      Address the feedback, then commit.
