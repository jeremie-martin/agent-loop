name: type-safety
description: Add type annotations progressively, starting with public interfaces

prompt_prefix: |
  Focus on type annotations that help catch bugs and improve editor support.
  Avoid over-complicated generic types that hurt readability.

prompt_suffix: |
  Do not commit changes - they will be reviewed and committed at the end of the cycle.
  Do not use the "question" tool or any tool requiring user input.

modes:
  - name: boundaries
    prompt: |
      Public interfaces deserve type annotations. They're the contract between modules, and type checkers can verify callers use them correctly.

      Identify public functions, methods, and classesâ€”anything that other modules import and use. For each:
      - Add parameter type annotations
      - Add explicit return type annotations
      - Document None returns as `-> None`

      Start with the most-used interfaces. Skip internal helpers for now; they'll be addressed in the next phase.

      After adding annotations, run the type checker to catch any errors introduced.

  - name: internals
    prompt: |
      Internal code benefits from types where inference is ambiguous or where the type isn't obvious from context.

      Review internal functions and local variables. Add annotations where:
      - The type isn't obvious from the assignment (e.g., empty containers)
      - Multiple types could be valid and you're specifying which
      - Complex expressions make the resulting type unclear

      Don't annotate everything. `x: int = 5` adds noise. `result: dict[str, list[Event]] = {}` adds clarity.

      Run the type checker after each file to catch issues early.

  - name: strictness
    prompt: |
      Review existing annotations for precision and correctness.

      Look for:
      - Bare `list`, `dict`, `tuple` without type parameters
      - `Any` used where a specific type is known
      - Missing `Optional` for values that can be None
      - Places where type narrowing would help (isinstance checks, None guards)

      Tighten loose types. Replace `Any` with specific types where the actual type is known. Add Optional where None is a valid value.

      The goal is types that accurately describe what the code does, not maximally strict types that fight the code.

review:
  enabled: true
  scope_globs:
    - "src/**/*.py"
    - "lib/**/*.py"
  check_prompt: |
    Review only the Python source files (not tests). Ignore unrelated files.

    For each modified file, verify:
    1. Type annotations are syntactically correct
    2. The type checker passes (run mypy or pyright)
    3. Annotations match actual runtime behavior

    Run the project's type checker to confirm no errors were introduced.

  filter_prompt: |
    Filter out:
    - Suggestions for more complex generic types
    - Opinions about typing style (Union vs |, Optional vs | None)
    - Requests to annotate test files (out of scope)
    - Concerns about files outside the source directories

    Only act on type errors or incorrect annotations.
