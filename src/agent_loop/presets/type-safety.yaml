name: type-safety
description: Add type annotations with self-orchestrated verification

prompt_prefix: |
  FIRST: Find and read all markdown documentation in this project before doing anything else.
  Search for and read: README files (root and subdirectories), CLAUDE.md, AGENTS.md, and all
  files in docs/ or documentation/ directories. Understand the codebase's patterns, conventions,
  and architecture. Only then proceed with your task. Sub-agents you spawn must do the same.

prompt_suffix: |
  Do not use the "question" tool or any tool requiring user input.
  Stage and commit your changes at the end with a descriptive message.

modes:
  - name: boundaries
    prompt: |
      Type public interfaces thoroughly. These are the contracts between modules,
      and type checkers can verify callers use them correctly.

      Identify public functions, methods, and classesâ€”anything other modules import
      and use. For each:
      - Add parameter type annotations
      - Add explicit return type annotations
      - Document None returns as `-> None`

      For internal code, add annotations where:
      - The type isn't obvious from the assignment (e.g., empty containers)
      - Multiple types could be valid and you're specifying which
      - Complex expressions make the resulting type unclear

      Don't over-annotate. `x: int = 5` adds noise. `result: dict[str, list[Event]] = {}`
      adds clarity.

      Review existing annotations for precision:
      - Replace bare `list`, `dict`, `tuple` with parameterized versions
      - Replace `Any` with specific types where the actual type is known
      - Add `Optional` or `| None` where None is a valid value

      The goal is types that accurately describe what the code does, not maximally
      strict types that fight the code.

      Run the type checker after changes to catch errors.

      **After completing your changes**, orchestrate verification:

      1. Spawn a sub-agent to review your work. Give it:
         - This task (type safety improvement)
         - The files you modified
         - Instruction to check: are annotations correct? Does the type checker pass?
           Are there over-complicated generic types that hurt readability?

      2. Spawn a filter sub-agent. Give it the verification feedback and ask:
         which concerns are genuine vs stylistic preference?

      3. Address filtered feedback, then commit.

  - name: consistency
    prompt: |
      Ensure type annotations are consistent across the codebase.

      Similar code should use similar types. Review for:
      - Duplicate type definitions that could be consolidated
      - Inconsistent naming (is it `UserId` or `UserID`?)
      - Similar functions with different annotation styles
      - Places where type narrowing would help (isinstance checks, None guards)

      Consolidate type definitions. Create type aliases for complex types used in
      multiple places. Ensure naming conventions are predictable.

      Run the type checker after changes.

      **After your changes**, run the same verification pattern, then commit.
