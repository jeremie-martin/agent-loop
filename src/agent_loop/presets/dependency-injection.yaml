name: dependency-injection
description: Reduce tight coupling by introducing dependency injection

prompt_prefix: |
  FIRST: Find and read all markdown documentation in this project before doing anything else.
  Search for and read: README files (root and subdirectories), CLAUDE.md, AGENTS.md, and all
  files in docs/ or documentation/ directories. Understand the codebase's patterns, conventions,
  and architecture. Only then proceed with your task.

  When spawning sub-agents, explicitly instruct each one to first read all project
  documentation (README files, CLAUDE.md, AGENTS.md, docs/ and documentation/ directories)
  before starting its task.

prompt_suffix: |
  Do not use the "question" tool or any tool requiring user input.
  Stage and commit your changes at the end with a descriptive message.

modes:
  - name: inject
    prompt: |
      Tight coupling makes code hard to test and hard to change. When a class
      creates its own dependencies, you can't substitute them.

      Find coupling that would benefit from injection:

      **Direct instantiation**: Classes that create collaborators internally.
      `self.db = Database()` can't be tested with a mock database.

      **Hidden dependencies**: Functions that import and use modules internally.
      Dependencies not visible from the signature require monkeypatching to test.

      **Global state**: Module-level instances, singletons, deep config access.
      Hard to isolate, hard to test, hard to reason about.

      Not everything needs injection. Leave alone:
      - Simple utility functions with no side effects
      - Value objects and data structures
      - Dependencies that are truly fixed

      Apply injection using the simplest approach that works:

      **Constructor injection** (preferred):
      ```python
      def __init__(self, db: Database):
          self.db = db
      ```

      **Default injection** (backward compatible):
      ```python
      def __init__(self, db: Database | None = None):
          self.db = db or Database()
      ```

      Push dependency creation up to callers. Eventually, dependencies are
      created at entry points (main, app factory).

      Update tests to pass dependencies explicitly instead of monkeypatching.

      Don't introduce a DI framework unless the codebase already uses one.
      Manual injection is simpler and more explicit.

      If coupling is already reasonable, "no changes needed" is valid.

      **After completing your changes**, orchestrate verification:

      1. Spawn a sub-agent to review your work. Give it:
         - The files you modified
         - Instruction to check: is DI applied consistently? Do tests pass?
           Any awkward dependency chains?

      2. Spawn a filter sub-agent. Give it the verification feedback and ask:
         which concerns are genuine issues vs preferences?

      3. Address filtered feedback, then commit.
