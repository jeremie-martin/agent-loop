name: dependency-injection
description: Reduce tight coupling by introducing dependency injection

prompt_prefix: |
  FIRST: Find and read all markdown documentation in this project before doing anything else.
  Search for and read: README files (root and subdirectories), CLAUDE.md, AGENTS.md, and all
  files in docs/ or documentation/ directories. Understand the codebase's patterns, conventions,
  and architecture. Only then proceed with your task.

  When spawning sub-agents, explicitly instruct each one to first read all project
  documentation (README files, CLAUDE.md, AGENTS.md, docs/ and documentation/ directories)
  before starting its task.

prompt_suffix: |
  Do not use the "question" tool or any tool requiring user input.
  Stage and commit your changes at the end with a descriptive message.

modes:
  - name: inject
    prompt: |
      Well-designed code makes dependencies explicit. You can see what a class
      needs from its constructor, and you can substitute those dependencies for
      testing or different environments.

      Coupling patterns that benefit from injection:
      - **Direct instantiation**: `self.db = Database()` can't use a mock
      - **Hidden dependencies**: Imports inside functions hide what's needed
      - **Global state**: Singletons and module-level instances are hard to isolate

      Leave alone:
      - Simple utility functions with no side effects
      - Value objects and data structures
      - Dependencies that are truly fixed

      Apply injection using the simplest approach:

      ```python
      # Constructor injection (preferred)
      def __init__(self, db: Database):
          self.db = db

      # Default injection (backward compatible)
      def __init__(self, db: Database | None = None):
          self.db = db or Database()
      ```

      Focus on dependencies that make testing difficult. A few well-chosen
      injections are better than applying the pattern everywhere.

      Don't introduce a DI framework unless the codebase already uses one.
      Manual injection is simpler and more explicit.

      If coupling is already reasonable, "no changes needed" is valid.

      **After completing your changes**, orchestrate verification:

      1. Spawn a sub-agent to review your work. Give it:
         - The files you modified
         - Instruction to check: is DI applied consistently? Do tests pass?
           Any awkward dependency chains?

      2. Spawn a filter sub-agent. Give it the verification feedback and ask:
         which concerns are genuine issues vs preferences?

      3. Address filtered feedback, then commit.
