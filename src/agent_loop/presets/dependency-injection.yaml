name: dependency-injection
description: Reduce tight coupling by introducing dependency injection

prompt_prefix: |
  FIRST: Find and read all markdown documentation in this project before doing anything else.
  Search for and read: README files (root and subdirectories), CLAUDE.md, AGENTS.md, and all
  files in docs/ or documentation/ directories. Understand the codebase's patterns, conventions,
  and architecture. Only then proceed with your task.

  IMPORTANT - When spawning sub-agents:
  Sub-agents do not automatically have the context you have. For each sub-agent you spawn:
  1. Give it the exact file paths to relevant documentation (CLAUDE.md, README, etc.)
  2. Explicitly instruct it to read those files completely before starting its task
  3. Include any other specific files it needs to examine

  Do not assume sub-agents will find documentation on their own â€” give them the paths.

prompt_suffix: |
  Do not use the "question" tool or any tool requiring user input.
  Stage and commit your changes at the end with a descriptive message.

modes:
  - name: inject
    prompt: |
      Well-designed code makes dependencies explicit. You can see what a class
      needs from its constructor, and you can substitute those dependencies for
      testing or different environments.

      Coupling patterns that benefit from injection:
      - **Direct instantiation**: `self.db = Database()` can't use a mock
      - **Hidden dependencies**: Imports inside functions hide what's needed
      - **Global state**: Singletons and module-level instances are hard to isolate

      Leave alone:
      - Simple utility functions with no side effects
      - Value objects and data structures
      - Dependencies that are truly fixed

      Apply injection using the simplest approach:

      ```python
      # Constructor injection (preferred)
      def __init__(self, db: Database):
          self.db = db

      # Default injection (backward compatible)
      def __init__(self, db: Database | None = None):
          self.db = db or Database()
      ```

      Focus on dependencies that make testing difficult. A few well-chosen
      injections are better than applying the pattern everywhere.

      Don't introduce a DI framework unless the codebase already uses one.
      Manual injection is simpler and more explicit.

      If coupling is already reasonable, "no changes needed" is valid.

      **After completing your changes**, orchestrate verification:

      1. Spawn a sub-agent to review your work. Give it:
         - The paths to relevant documentation files and instruct it to read them first
         - The files you modified
         - Instruction to check: is DI applied consistently? Do tests pass?
           Any awkward dependency chains?

      2. Spawn a filter sub-agent. Give it the verification feedback and ask:
         which concerns are genuine issues vs preferences?

      3. Address filtered feedback, then commit.
