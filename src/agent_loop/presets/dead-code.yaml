name: dead-code
description: Find and remove unused code

prompt_prefix: |
  FIRST: Find and read all markdown documentation in this project before doing anything else.
  Search for and read: README files (root and subdirectories), CLAUDE.md, AGENTS.md, and all
  files in docs/ or documentation/ directories. Understand the codebase's patterns, conventions,
  and architecture. Only then proceed with your task.

  When spawning sub-agents, explicitly instruct each one to first read all project
  documentation (README files, CLAUDE.md, AGENTS.md, docs/ and documentation/ directories)
  before starting its task.

prompt_suffix: |
  Do not use the "question" tool or any tool requiring user input.
  Stage and commit your changes at the end with a descriptive message.

modes:
  - name: removal
    prompt: |
      A clean codebase contains only code that runs. Every function is called,
      every import is used, every variable is read. Dead code is weight—it
      confuses readers, clutters search results, and sometimes hides bugs.

      Dead code includes:
      - Imports that nothing uses
      - Functions/methods defined but never called
      - Classes never instantiated or subclassed
      - Variables assigned but never read
      - Commented-out code blocks
      - Unreachable code after return/raise/break

      Focus on clear wins—code that is obviously dead. Before removing anything,
      verify it's genuinely unused by searching for references, checking for
      dynamic access (getattr, reflection), and considering external entry
      points (CLI, API, plugins, framework magic).

      Be conservative. Only remove code you're confident is unused. A few
      well-verified removals are better than aggressive deletions that break
      things. If tests fail after removal, the code wasn't dead—restore it.

      Delete dead code entirely; don't comment it out. Clean up any imports or
      variables that become unused as a result.

      If the codebase is already clean, "no changes needed" is a valid outcome.

      **After completing your changes**, orchestrate verification:

      1. Spawn a sub-agent to review your work. Give it:
         - The files you modified
         - Instruction to check: do tests pass? Any remaining references to
           removed code? Any accidentally removed code that was actually used?

      2. Spawn a filter sub-agent. Give it the verification feedback and ask:
         which concerns are genuine issues vs over-caution?

      3. Address filtered feedback, then commit.
