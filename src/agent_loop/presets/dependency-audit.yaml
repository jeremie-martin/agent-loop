name: dependency-audit
description: Audit dependencies for currency, necessity, and version hygiene

prompt_suffix: Commit any changes you make. Do not use the "question" tool or any tool requiring user input.

modes:
  - name: outdated
    prompt: |
      Old dependencies carry old bugs—including security vulnerabilities that have long since been patched upstream.

      Examine the project's dependency manifest(s) and identify what's out of date. Check for: dependencies multiple major versions behind, packages with known security advisories, dependencies that are no longer maintained.

      Spawn a sub-agent to research the changelog and migration path for any significantly outdated dependency before deciding on updates.

      prompt_suffix: Commit any changes you make. Do not use the "question" tool or any tool requiring user input. Do not use the "question" tool or any tool requiring user input.
  - name: unused
    prompt: |
      Every dependency is a liability: maintenance burden, security surface, build time, supply chain risk. Dependencies should earn their place.

      Compare declared dependencies against actual usage. Look for: packages listed but never imported, packages imported only in dead code, packages that duplicate functionality already present.

      Use sub-agents to search the codebase for imports from each dependency if the project is large.

      Remove dependencies that aren't pulling their weight. But verify first—some dependencies provide runtime functionality without explicit imports, or are peer dependencies required by others.

  - naprompt_suffix: Commit any changes you make. Do not use the "question" tool or any tool requiring user input. Do not use the "question" tool or any tool requiring user input.    prompt: |
      Reproducibility requires knowing exactly what you're running. Floating versions mean different builds on different days—and debugging "it works on my machine" forever.

      Review version specifications in dependency manifests. Are versions pinned precisely, or do they float? Are lock files present and committed? Do production and development dependencies have appropriate pinning strategies?

      Tighten version specs where builds should be reproducible. Ensure lock files exist and are committed. But allow appropriate flexibility for libraries (which shouldn't over-constrain their consumers).
prompt_suffix: Commit any changes you make. Do not use the "question" tool or any tool requiring user input. Do not use the "question" tool or any tool requiring user input.