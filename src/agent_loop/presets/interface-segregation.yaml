name: interface-segregation
description: Split bloated interfaces into focused contracts

prompt_prefix: |
  FIRST: Find and read all markdown documentation in this project before doing anything else.
  Search for and read: README files (root and subdirectories), CLAUDE.md, AGENTS.md, and all
  files in docs/ or documentation/ directories. Understand the codebase's patterns, conventions,
  and architecture. Only then proceed with your task.

  When spawning sub-agents, explicitly instruct each one to first read all project
  documentation (README files, CLAUDE.md, AGENTS.md, docs/ and documentation/ directories)
  before starting its task.

prompt_suffix: |
  Do not use the "question" tool or any tool requiring user input.
  Stage and commit your changes at the end with a descriptive message.

modes:
  - name: segregate
    prompt: |
      Well-designed interfaces are focused. Clients depend only on methods they
      use, implementers don't have stub methods, and each interface has a single
      clear purpose.

      Signs of bloated interfaces:
      - Implementers with `pass` or `NotImplementedError` for some methods
      - Different clients using completely different method subsets
      - Methods bundled together that don't share state or purpose

      Leave alone:
      - Interfaces where all methods are genuinely related
      - Interfaces where all implementers use all methods
      - Standard library interfaces with established contracts

      Split bloated interfaces into focused ones. Name them by what they do:
      `UserRepository` might become `UserReader` and `UserWriter`. If clients
      commonly need multiple interfaces, provide a composed interface.

      Focus on interfaces that cause real problemsâ€”stub implementations, awkward
      dependencies. A few meaningful splits are better than fragmenting everything.

      Run tests frequently. Interface changes often cause subtle breaks.

      If interfaces are already well-segregated, "no changes needed" is valid.

      **After completing your changes**, orchestrate verification:

      1. Spawn a sub-agent to review your work. Give it:
         - The files you modified
         - Instruction to check: are new interfaces cohesive? Do tests pass?
           Any clients using the wrong interface?

      2. Spawn a filter sub-agent. Give it the verification feedback and ask:
         which concerns are genuine issues vs design taste?

      3. Address filtered feedback, then commit.
