name: interface-segregation
description: Split bloated interfaces into focused contracts

prompt_prefix: |
  FIRST: Find and read all markdown documentation in this project before doing anything else.
  Search for and read: README files (root and subdirectories), CLAUDE.md, AGENTS.md, and all
  files in docs/ or documentation/ directories. Understand the codebase's patterns, conventions,
  and architecture. Only then proceed with your task.

  IMPORTANT - When spawning sub-agents:
  Sub-agents do not automatically have the context you have. For each sub-agent you spawn:
  1. Give it the exact file paths to relevant documentation (CLAUDE.md, README, etc.)
  2. Explicitly instruct it to read those files completely before starting its task
  3. Include any other specific files it needs to examine

  Do not assume sub-agents will find documentation on their own — give them the paths.

prompt_suffix: |
  Do not use the "question" tool or any tool requiring user input.
  Stage and commit your changes at the end with a descriptive message.

modes:
  - name: segregate
    prompt: |
      Well-designed interfaces are focused. Clients depend only on methods they
      use, implementers don't have stub methods, and each interface has a single
      clear purpose.

      Signs of bloated interfaces:
      - Implementers with `pass` or `NotImplementedError` for some methods
      - Different clients using completely different method subsets
      - Methods bundled together that don't share state or purpose

      Leave alone:
      - Interfaces where all methods are genuinely related
      - Interfaces where all implementers use all methods
      - Standard library interfaces with established contracts

      Split bloated interfaces into focused ones. Name them by what they do:
      `UserRepository` might become `UserReader` and `UserWriter`. If clients
      commonly need multiple interfaces, provide a composed interface.

      Focus on interfaces that cause real problems—stub implementations, awkward
      dependencies. A few meaningful splits are better than fragmenting everything.

      Run tests frequently. Interface changes often cause subtle breaks.

      If interfaces are already well-segregated, "no changes needed" is valid.

      **After completing your changes**, orchestrate verification:

      1. Spawn a sub-agent to review your work. Give it:
         - The paths to relevant documentation files and instruct it to read them first
         - The files you modified
         - Instruction to check: are new interfaces cohesive? Do tests pass?
           Any clients using the wrong interface?

      2. Spawn a filter sub-agent. Give it the verification feedback and ask:
         which concerns are genuine issues vs design taste?

      3. Address filtered feedback, then commit.
